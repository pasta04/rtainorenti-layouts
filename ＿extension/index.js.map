{"version":3,"file":"index.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC5IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACtMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AChIA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;;;;;ACAA;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AEvBA;AACA;AACA;AACA","sources":["webpack://rtainorenti-layouts/./src/extension/challonge.ts","webpack://rtainorenti-layouts/./src/extension/checklist.ts","webpack://rtainorenti-layouts/./src/extension/default/checklist.ts","webpack://rtainorenti-layouts/./src/extension/index.ts","webpack://rtainorenti-layouts/./src/extension/schedule-import.ts","webpack://rtainorenti-layouts/./src/extension/schedule.ts","webpack://rtainorenti-layouts/./src/extension/timekeeping.ts","webpack://rtainorenti-layouts/./src/extension/twitch.ts","webpack://rtainorenti-layouts/./src/nodecg/timer.ts","webpack://rtainorenti-layouts/external commonjs \"app-root-path\"","webpack://rtainorenti-layouts/external commonjs \"googleapis\"","webpack://rtainorenti-layouts/external commonjs \"got\"","webpack://rtainorenti-layouts/external commonjs \"lodash\"","webpack://rtainorenti-layouts/external commonjs \"moment\"","webpack://rtainorenti-layouts/external commonjs \"source-map-support/register\"","webpack://rtainorenti-layouts/external commonjs \"tslib\"","webpack://rtainorenti-layouts/external node-commonjs \"timers\"","webpack://rtainorenti-layouts/webpack/bootstrap","webpack://rtainorenti-layouts/webpack/before-startup","webpack://rtainorenti-layouts/webpack/startup","webpack://rtainorenti-layouts/webpack/after-startup"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.tournamentCurrent = exports.challonge = void 0;\r\nconst tslib_1 = require(\"tslib\");\r\nconst got_1 = (0, tslib_1.__importDefault)(require(\"got\"));\r\n/** Challongeのトーナメント情報を取得する */\r\nconst challonge = (nodecg) => {\r\n    const { challongeApiKey } = nodecg.bundleConfig;\r\n    const challongeRep = nodecg.Replicant('challonge', {\r\n        defaultValue: {\r\n            tournamentId: '',\r\n            tournamentName: '',\r\n            data: [],\r\n        },\r\n    });\r\n    const log = new nodecg.Logger('challonge');\r\n    const fetchTournament = async (tournamentId) => {\r\n        const url = `https://api.challonge.com/v1/tournaments/${tournamentId}.json?api_key=${challongeApiKey}`;\r\n        log.debug(`url access: ${url}`);\r\n        const { body } = await (0, got_1.default)(url);\r\n        const json = JSON.parse(body);\r\n        log.debug(JSON.stringify(json, null, '  '));\r\n        return json;\r\n    };\r\n    const fetchParticipants = async (tournamentId) => {\r\n        const url = `https://api.challonge.com/v1/tournaments/${tournamentId}/participants.json?api_key=${challongeApiKey}`;\r\n        log.debug(`url access: ${url}`);\r\n        const { body } = await (0, got_1.default)(url);\r\n        const json = JSON.parse(body);\r\n        log.debug(JSON.stringify(json, null, '  '));\r\n        return json;\r\n    };\r\n    const fetchMatch = async (tournamentId) => {\r\n        const url = `https://api.challonge.com/v1/tournaments/${tournamentId}/matches.json?api_key=${challongeApiKey}`;\r\n        log.debug(`url access: ${url}`);\r\n        const { body } = await (0, got_1.default)(url);\r\n        const json = JSON.parse(body);\r\n        log.debug(JSON.stringify(json, null, '  '));\r\n        return json;\r\n    };\r\n    const fetchTournamentInfo = async () => {\r\n        const tournamentId = challongeRep.value.tournamentId;\r\n        if (!tournamentId)\r\n            return;\r\n        // 参加者を取得\r\n        const participants = await fetchParticipants(tournamentId);\r\n        const playerIdToName = {};\r\n        participants.map((pa) => {\r\n            playerIdToName[pa.participant.id] = pa.participant.display_name;\r\n        });\r\n        // トーナメント情報を取得\r\n        const matchInfo = await fetchMatch(tournamentId);\r\n        // トーナメント情報と走者情報をマージ\r\n        const newInfo = matchInfo.map((ma) => {\r\n            return {\r\n                match: {\r\n                    player1_name: playerIdToName[ma.match.player1_id] ?? '',\r\n                    player2_name: playerIdToName[ma.match.player2_id] ?? '',\r\n                    ...ma.match,\r\n                },\r\n            };\r\n        });\r\n        challongeRep.value = {\r\n            ...challongeRep.value,\r\n            data: newInfo,\r\n        };\r\n    };\r\n    /** 画面で入力されたIDとタイトルを格納する */\r\n    const fetchTournamentInfoHandler = async (tournamentId) => {\r\n        log.info(`tournamentId: ${tournamentId}`);\r\n        // タイトルを取得\r\n        try {\r\n            const tournament = await fetchTournament(tournamentId);\r\n            const tournamentName = tournament ? tournament.tournament.name : '';\r\n            challongeRep.value = {\r\n                tournamentId,\r\n                tournamentName,\r\n                data: [],\r\n            };\r\n            await fetchTournamentInfo();\r\n        }\r\n        catch (e) {\r\n            log.error(e);\r\n            challongeRep.value = {\r\n                tournamentId: '',\r\n                tournamentName: '',\r\n                data: [],\r\n            };\r\n        }\r\n    };\r\n    // 定期的に取得\r\n    setInterval(fetchTournamentInfo, 10 * 1000);\r\n    nodecg.listenFor('fetchTournament', fetchTournamentInfoHandler);\r\n};\r\nexports.challonge = challonge;\r\nconst tournamentCurrent = (nodecg) => {\r\n    const rep = nodecg.Replicant('tournamentCurrent', {\r\n        defaultValue: {\r\n            title: '',\r\n            runner1: {\r\n                round: 0,\r\n            },\r\n            runner2: {\r\n                round: 0,\r\n            },\r\n            runner3: {\r\n                round: 0,\r\n            },\r\n            runner4: {\r\n                round: 0,\r\n            },\r\n        },\r\n    });\r\n    // 試合名更新\r\n    const editMatchname = (payload) => {\r\n        rep.value = {\r\n            ...rep.value,\r\n            title: payload,\r\n        };\r\n    };\r\n    const editMatchRound = (payload) => {\r\n        rep.value = {\r\n            ...rep.value,\r\n            runner1: {\r\n                round: payload.index === 0 ? payload.round : rep.value.runner1.round,\r\n            },\r\n            runner2: {\r\n                round: payload.index === 1 ? payload.round : rep.value.runner2.round,\r\n            },\r\n            runner3: {\r\n                round: payload.index === 2 ? payload.round : rep.value.runner3.round,\r\n            },\r\n            runner4: {\r\n                round: payload.index === 3 ? payload.round : rep.value.runner4.round,\r\n            },\r\n        };\r\n    };\r\n    nodecg.listenFor('editMatchname', editMatchname);\r\n    nodecg.listenFor('editMatchRound', editMatchRound);\r\n};\r\nexports.tournamentCurrent = tournamentCurrent;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.checklist = void 0;\r\nconst tslib_1 = require(\"tslib\");\r\nconst lodash_1 = require(\"lodash\");\r\nconst checklist_1 = (0, tslib_1.__importDefault)(require(\"./default/checklist\"));\r\n/** チェックリストの制御 */\r\nconst checklist = (nodecg) => {\r\n    const checklistRep = nodecg.Replicant('checklist', {\r\n        defaultValue: checklist_1.default,\r\n    });\r\n    if (checklistRep.value) {\r\n        const currentNameList = checklistRep.value.map((item) => item.name);\r\n        const defaultNameList = checklist_1.default.map((item) => item.name);\r\n        if (!(0, lodash_1.isEqual)(currentNameList, defaultNameList)) {\r\n            if (checklistRep.value.every((item) => item.complete)) {\r\n                checklistRep.value = checklist_1.default.map((item) => ({\r\n                    name: item.name,\r\n                    complete: true,\r\n                }));\r\n            }\r\n            else {\r\n                checklistRep.value = checklist_1.default;\r\n            }\r\n        }\r\n    }\r\n    const toggleCheckbox = (payload) => {\r\n        if (!checklistRep.value) {\r\n            return;\r\n        }\r\n        const item = checklistRep.value.find((item) => item.name === payload.name);\r\n        if (item) {\r\n            item.complete = payload.checked;\r\n        }\r\n    };\r\n    const resetChecklist = () => {\r\n        if (!checklistRep.value) {\r\n            return;\r\n        }\r\n        for (const item of checklistRep.value) {\r\n            item.complete = false;\r\n        }\r\n    };\r\n    nodecg.listenFor('toggleCheckbox', toggleCheckbox);\r\n    nodecg.listenFor('resetChecklist', resetChecklist);\r\n};\r\nexports.checklist = checklist;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n// チェックリストの内容とデフォルト値\r\nlet i = 1;\r\nexports.default = [\r\n    { name: `${i++}. 走者とゲームの情報を確認`, complete: false },\r\n    { name: `${i++}. 正しいレイアウトを選択`, complete: false },\r\n    { name: `${i++}. 走者とゲーム画面が一致`, complete: false },\r\n    { name: `${i++}. クロップをリセット`, complete: false },\r\n    { name: `${i++}. ゲーム画面をクロップ`, complete: false },\r\n    { name: `${i++}. Steam通知ポップアップOFF`, complete: false },\r\n    { name: `${i++}. 音声の準備ができた`, complete: false },\r\n];\r\n","\"use strict\";\r\nconst tslib_1 = require(\"tslib\");\r\nrequire(\"source-map-support/register\");\r\nconst checklist_1 = require(\"./checklist\");\r\nconst schedule_1 = (0, tslib_1.__importDefault)(require(\"./schedule\"));\r\nconst timekeeping_1 = require(\"./timekeeping\");\r\nconst twitch_1 = require(\"./twitch\");\r\nconst challonge_1 = require(\"./challonge\");\r\nmodule.exports = (nodecg) => {\r\n    (0, checklist_1.checklist)(nodecg);\r\n    (0, schedule_1.default)(nodecg);\r\n    (0, timekeeping_1.timekeeping)(nodecg);\r\n    (0, twitch_1.twitch)(nodecg);\r\n    (0, challonge_1.challonge)(nodecg);\r\n    (0, challonge_1.tournamentCurrent)(nodecg);\r\n};\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.importFromOengus = void 0;\r\nconst tslib_1 = require(\"tslib\");\r\nconst timers_1 = require(\"timers\");\r\nconst got_1 = (0, tslib_1.__importDefault)(require(\"got\"));\r\nconst moment_1 = (0, tslib_1.__importDefault)(require(\"moment\"));\r\nconst googleapis_1 = require(\"googleapis\");\r\nconst lodash_1 = require(\"lodash\");\r\nconst fetchSchedule = async (marathonId) => {\r\n    const res = await got_1.default.get(`https://oengus.io/api/marathons/${marathonId}/schedule`, { json: true });\r\n    return res.body;\r\n};\r\nconst padZero = (num) => {\r\n    return (0, lodash_1.padStart)(String(num), 2, '0');\r\n};\r\nconst formatDuration = (duration) => {\r\n    const momentDuration = moment_1.default.duration(duration);\r\n    const hours = momentDuration.hours();\r\n    const minutes = momentDuration.minutes();\r\n    const seconds = momentDuration.seconds();\r\n    return `${hours}:${padZero(minutes)}:${padZero(seconds)}`;\r\n};\r\nconst importFromOengus = (nodecg) => {\r\n    const logger = new nodecg.Logger('schedule:oengus');\r\n    const { oengusMarathonId, spreadsheetId, googleApiKey } = nodecg.bundleConfig;\r\n    if (!oengusMarathonId) {\r\n        logger.warn('Oengus config is empty');\r\n        return;\r\n    }\r\n    if (!spreadsheetId) {\r\n        logger.warn('Spreadsheet is empty');\r\n        return;\r\n    }\r\n    if (!googleApiKey) {\r\n        logger.warn('Google API key config is empty');\r\n        return;\r\n    }\r\n    const sheetsApi = googleapis_1.google.sheets({\r\n        version: 'v4',\r\n        auth: googleApiKey,\r\n    });\r\n    /** 解説情報を取得 */\r\n    const fetchCommentators = async () => {\r\n        // logger.info('run fetchCommentators');\r\n        // 1行に1ゲームの全解説者が詰まっている\r\n        const res = await sheetsApi.spreadsheets.values.batchGet({\r\n            spreadsheetId: spreadsheetId,\r\n            ranges: ['RRR走者情報'],\r\n        });\r\n        const sheetValues = res.data.valueRanges;\r\n        if (!sheetValues || !sheetValues[0] || !sheetValues[0].values) {\r\n            throw new Error('Could not get values from spreadsheet');\r\n        }\r\n        const [labels, ...contents] = sheetValues[0].values;\r\n        if (!labels) {\r\n            throw new Error('Could not get values from spreadsheet');\r\n        }\r\n        let rawData1 = contents.map((content) => (0, lodash_1.zipObject)(labels, content));\r\n        const rawData2 = rawData1.map((el) => {\r\n            const result = [];\r\n            const gameCategory = el['ゲーム名'];\r\n            const commentary1 = el['解説者1 お名前'];\r\n            const commentary2 = el['解説者2 お名前'];\r\n            if (commentary1) {\r\n                result.push({\r\n                    gameCategory,\r\n                    name: commentary1,\r\n                });\r\n            }\r\n            if (commentary2) {\r\n                result.push({\r\n                    gameCategory,\r\n                    name: commentary2,\r\n                });\r\n            }\r\n            return result;\r\n        });\r\n        let rawData3 = rawData2.reduce((pre, current) => {\r\n            pre.push(...current);\r\n            return pre;\r\n        }, []);\r\n        // logger.info(rawData3);\r\n        return rawData3;\r\n    };\r\n    logger.warn('Using Oengus to import schedule');\r\n    const scheduleRep = nodecg.Replicant('schedule');\r\n    const updateSchedule = async () => {\r\n        try {\r\n            logger.info('run updateSchedule');\r\n            const [schedule, rawCommentators] = await Promise.all([\r\n                fetchSchedule(oengusMarathonId),\r\n                fetchCommentators(),\r\n            ]);\r\n            logger.info('fetch done');\r\n            scheduleRep.value = schedule.lines.map((run, index) => {\r\n                const runners = run.runners.map((runner) => {\r\n                    return {\r\n                        name: runner.usernameJapanese || runner.username,\r\n                        twitch: runner.connections.find((c) => c.platform === 'TWITCH')\r\n                            ?.username || undefined,\r\n                        twitter: runner.connections.find((c) => c.platform === 'TWITTER')\r\n                            ?.username || undefined,\r\n                        nico: runner.connections.find((c) => c.platform === 'NICO')?.username ||\r\n                            undefined,\r\n                    };\r\n                });\r\n                const gameCategory = run.gameName.trim();\r\n                const commentators = rawCommentators.filter((c) => c.gameCategory === gameCategory);\r\n                // logger.info(run.gameName);\r\n                return {\r\n                    pk: run.id,\r\n                    index,\r\n                    title: run.gameName,\r\n                    englishTitle: '',\r\n                    category: run.categoryName,\r\n                    platform: run.console,\r\n                    runDuration: formatDuration(run.estimate),\r\n                    setupDuration: formatDuration(run.setupTime),\r\n                    runners,\r\n                    commentators: commentators.map((c) => ({\r\n                        name: c.name,\r\n                        // twitch: c.twitch,\r\n                        // twitter: c.twitter,\r\n                        // nico: c.nico,\r\n                    })),\r\n                };\r\n            });\r\n        }\r\n        catch (error) {\r\n            logger.error('Failed to fetch schedule');\r\n            logger.error(error);\r\n        }\r\n    };\r\n    updateSchedule();\r\n    (0, timers_1.setInterval)(updateSchedule, 10 * 1000);\r\n};\r\nexports.importFromOengus = importFromOengus;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst lodash_1 = require(\"lodash\");\r\nconst schedule_import_1 = require(\"./schedule-import\");\r\nexports.default = async (nodecg) => {\r\n    // const logger = new nodecg.Logger('schedule');\r\n    // スケジュール取得、及び定期実行\r\n    (0, schedule_import_1.importFromOengus)(nodecg);\r\n    const scheduleRep = nodecg.Replicant('schedule', { defaultValue: [] });\r\n    const currentRunRep = nodecg.Replicant('current-run', { defaultValue: null });\r\n    const nextRunRep = nodecg.Replicant('next-run', { defaultValue: null });\r\n    const checklistRep = nodecg.Replicant('checklist', { defaultValue: [] });\r\n    /** チェックリスト */\r\n    const resetChecklist = () => {\r\n        if (checklistRep.value) {\r\n            checklistRep.value = checklistRep.value.map((item) => ({\r\n                ...item,\r\n                complete: false,\r\n            }));\r\n        }\r\n    };\r\n    /** ゲーム情報を更新。次へとか前へ押した時 */\r\n    const updateCurrentRun = (index) => {\r\n        if (!scheduleRep.value) {\r\n            return;\r\n        }\r\n        resetChecklist();\r\n        const newCurrentRun = scheduleRep.value[index];\r\n        if (!newCurrentRun) {\r\n            return;\r\n        }\r\n        currentRunRep.value = (0, lodash_1.cloneDeep)(newCurrentRun);\r\n        const next = scheduleRep.value[index + 1];\r\n        if (next) {\r\n            nextRunRep.value = (0, lodash_1.cloneDeep)(next);\r\n        }\r\n        else {\r\n            nextRunRep.value = {\r\n                commentators: [],\r\n                englishTitle: '',\r\n                index: 99999,\r\n                pk: 99999,\r\n                runDuration: '',\r\n                runners: [],\r\n                setupDuration: '',\r\n                title: '',\r\n            };\r\n        }\r\n    };\r\n    /** 次へボタン */\r\n    const seekToNextRun = () => {\r\n        if (!currentRunRep.value || !scheduleRep.value) {\r\n            return;\r\n        }\r\n        const currentIndex = currentRunRep.value.index;\r\n        if (currentIndex === undefined || currentIndex < 0) {\r\n            updateCurrentRun(0);\r\n            return;\r\n        }\r\n        // 既に最後ならもう押せない\r\n        if (currentIndex >= scheduleRep.value.length - 1) {\r\n            return;\r\n        }\r\n        resetChecklist();\r\n        currentRunRep.value = (0, lodash_1.cloneDeep)(nextRunRep.value);\r\n        const next = scheduleRep.value[currentIndex + 2];\r\n        if (next) {\r\n            nextRunRep.value = (0, lodash_1.cloneDeep)(next);\r\n        }\r\n        else {\r\n            nextRunRep.value = {\r\n                commentators: [],\r\n                englishTitle: '',\r\n                index: 99999,\r\n                pk: 99999,\r\n                runDuration: '',\r\n                runners: [],\r\n                setupDuration: '',\r\n                title: '',\r\n            };\r\n        }\r\n    };\r\n    /** 前へボタン */\r\n    const seekToPreviousRun = () => {\r\n        if (!currentRunRep.value || !scheduleRep.value) {\r\n            return;\r\n        }\r\n        const currentIndex = currentRunRep.value.index;\r\n        if (currentIndex === undefined || currentIndex < 0) {\r\n            updateCurrentRun(0);\r\n            return;\r\n        }\r\n        // 既に先頭ならそのまま\r\n        if (currentIndex === 0) {\r\n            return;\r\n        }\r\n        resetChecklist();\r\n        nextRunRep.value = (0, lodash_1.cloneDeep)(currentRunRep.value);\r\n        const current = scheduleRep.value[currentIndex - 1];\r\n        currentRunRep.value = (0, lodash_1.cloneDeep)(current);\r\n    };\r\n    nodecg.listenFor('nextRun', (_, cb) => {\r\n        seekToNextRun();\r\n        if (cb && !cb.handled) {\r\n            cb(null);\r\n        }\r\n    });\r\n    nodecg.listenFor('previousRun', (_, cb) => {\r\n        seekToPreviousRun();\r\n        if (cb && !cb.handled) {\r\n            cb(null);\r\n        }\r\n    });\r\n    nodecg.listenFor('setCurrentRunByIndex', (index, cb) => {\r\n        updateCurrentRun(index);\r\n        if (cb && !cb.handled) {\r\n            cb(null);\r\n        }\r\n    });\r\n    nodecg.listenFor('modifyRun', (data, cb) => {\r\n        if (!currentRunRep.value || !nextRunRep.value) {\r\n            return;\r\n        }\r\n        let msg = null;\r\n        try {\r\n            switch (data.pk) {\r\n                case currentRunRep.value.pk:\r\n                    currentRunRep.value = { ...currentRunRep.value, ...data };\r\n                    break;\r\n                case nextRunRep.value.pk:\r\n                    nextRunRep.value = { ...nextRunRep.value, ...data };\r\n                    break;\r\n                default:\r\n                    nodecg.log.warn('[modifyRun] run not found:', data);\r\n                    msg = 'Error: Run not found';\r\n                    break;\r\n            }\r\n            if (cb && !cb.handled) {\r\n                cb(msg);\r\n            }\r\n        }\r\n        catch (error) {\r\n            if (cb && !cb.handled) {\r\n                cb(error?.message);\r\n            }\r\n        }\r\n    });\r\n    // Prevent empty current run\r\n    scheduleRep.on('change', (newVal) => {\r\n        const isCurrentRunEmpty = !currentRunRep.value || !currentRunRep.value.pk;\r\n        if (isCurrentRunEmpty) {\r\n            const currentRun = newVal[0];\r\n            if (currentRun) {\r\n                currentRunRep.value = (0, lodash_1.cloneDeep)(currentRun);\r\n                nextRunRep.value = (0, lodash_1.cloneDeep)(newVal[1]);\r\n            }\r\n        }\r\n    });\r\n};\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.timekeeping = void 0;\r\nconst timer_1 = require(\"../nodecg/timer\");\r\nconst TRY_TICK_INTERVAL = 10;\r\nconst getDefaultTimer = () => (0, timer_1.newTimer)(0);\r\nconst timekeeping = (nodecg) => {\r\n    const checklistRep = nodecg.Replicant('checklist', { defaultValue: [] });\r\n    const currentRunRep = nodecg.Replicant('current-run', { defaultValue: null });\r\n    const timerRep = nodecg.Replicant('timer', {\r\n        defaultValue: getDefaultTimer(),\r\n    });\r\n    /**\r\n     * The UNIX time when the timer incremented last time\r\n     */\r\n    let lastIncrement = 0;\r\n    /**\r\n     * Keeps the timeout object\r\n     */\r\n    let tickInterval;\r\n    /**\r\n     * Increments the timer by one second if at least one second\r\n     * has passed since the last incerement.\r\n     * If it does, increament lastIncerement for 1000.\r\n     * Executing this function makes the timer very accurate to UNIX time,\r\n     * and can be easily extended to millisecond timer.\r\n     */\r\n    const tryTick = () => {\r\n        if (!timerRep.value) {\r\n            return;\r\n        }\r\n        if (Date.now() - lastIncrement > 1000) {\r\n            lastIncrement += 1000;\r\n            (0, timer_1.increment)(timerRep.value);\r\n        }\r\n    };\r\n    /**\r\n     * Starts the timer.\r\n     * @param force - Forces the timer to start again, even if already running.\r\n     */\r\n    const start = (force = false) => {\r\n        if (!timerRep.value) {\r\n            return;\r\n        }\r\n        // Don't start if checklist is not completed\r\n        if (!checklistRep.value ||\r\n            checklistRep.value.some((item) => !item.complete)) {\r\n            return;\r\n        }\r\n        // Don't start the time if it's already running\r\n        if (!force && timerRep.value.timerState === 'Running') {\r\n            return;\r\n        }\r\n        clearInterval(tickInterval);\r\n        timerRep.value.timerState = 'Running';\r\n        lastIncrement = Date.now();\r\n        tickInterval = setInterval(tryTick, TRY_TICK_INTERVAL);\r\n    };\r\n    /**\r\n     * Stops the timer.\r\n     */\r\n    const stop = () => {\r\n        if (!timerRep.value) {\r\n            return;\r\n        }\r\n        clearInterval(tickInterval);\r\n        timerRep.value.timerState = 'Stopped';\r\n    };\r\n    /**\r\n     * Stops and resets the timer, and clears the timer and results.\r\n     */\r\n    const reset = () => {\r\n        if (!timerRep.value) {\r\n            return;\r\n        }\r\n        stop();\r\n        (0, timer_1.setSeconds)(timerRep.value, 0);\r\n        timerRep.value.results = [];\r\n    };\r\n    /**\r\n     * Re-calculates the podium place for all runners.\r\n     */\r\n    const recalcPlaces = () => {\r\n        if (!timerRep.value || !currentRunRep.value) {\r\n            return;\r\n        }\r\n        const finishedResults = timerRep.value.results\r\n            .filter((result) => {\r\n            if (result) {\r\n                result.place = 0;\r\n                return !result.forfeit;\r\n            }\r\n            return false;\r\n        })\r\n            .sort((a, b) => {\r\n            if (!a) {\r\n                return -1;\r\n            }\r\n            if (!b) {\r\n                return 1;\r\n            }\r\n            return a.raw - b.raw;\r\n        });\r\n        finishedResults.forEach((r, index) => {\r\n            if (!r) {\r\n                return;\r\n            }\r\n            r.place = index + 1;\r\n        });\r\n        if (currentRunRep.value.runners === undefined) {\r\n            return;\r\n        }\r\n        const allRunnersFinished = currentRunRep.value.runners.every((_, index) => Boolean(timerRep.value && timerRep.value.results[index]));\r\n        if (allRunnersFinished) {\r\n            stop();\r\n            timerRep.value.timerState = 'Finished';\r\n        }\r\n    };\r\n    /**\r\n     * Marks a runner as complete.\r\n     * @param data.index - The runner to modify.\r\n     * @param data.forfeit - Whether or not the runner forfeit.\r\n     */\r\n    const completeRunner = (data) => {\r\n        if (!timerRep.value) {\r\n            return;\r\n        }\r\n        if (!timerRep.value.results[data.index]) {\r\n            timerRep.value.results[data.index] = (0, timer_1.newTimer)(timerRep.value.raw);\r\n        }\r\n        const result = timerRep.value.results[data.index];\r\n        if (result) {\r\n            result['forfeit'] = data.forfeit;\r\n            recalcPlaces();\r\n        }\r\n    };\r\n    /**\r\n     * Marks a runner as still running.\r\n     * @param index - The runner to modify.\r\n     */\r\n    const resumeRunner = (index) => {\r\n        if (!timerRep.value) {\r\n            return;\r\n        }\r\n        timerRep.value.results[index] = null;\r\n        recalcPlaces();\r\n        if (timerRep.value.timerState !== 'Finished') {\r\n            return;\r\n        }\r\n        const missedSeconds = Math.round((Date.now() - timerRep.value.timestamp) / 1000);\r\n        (0, timer_1.setSeconds)(timerRep.value, timerRep.value.raw + missedSeconds);\r\n        start();\r\n    };\r\n    /**\r\n     * Edits the final time of a results.\r\n     * @param index - The runner to modify time of.\r\n     * @param newTime - A hh:mm:ss/mm:ss formatted new time.\r\n     */\r\n    const editTime = ({ index, newTime, }) => {\r\n        if (!timerRep.value || !currentRunRep.value) {\r\n            return;\r\n        }\r\n        if (!newTime) {\r\n            return;\r\n        }\r\n        const newSeconds = (0, timer_1.parseSeconds)(newTime);\r\n        if (isNaN(newSeconds)) {\r\n            return;\r\n        }\r\n        if (index === 'master') {\r\n            (0, timer_1.setSeconds)(timerRep.value, newSeconds);\r\n            return;\r\n        }\r\n        const result = timerRep.value.results[index];\r\n        if (!result) {\r\n            return;\r\n        }\r\n        (0, timer_1.setSeconds)(result, newSeconds);\r\n        recalcPlaces();\r\n        if (currentRunRep.value.runners &&\r\n            currentRunRep.value.runners.length === 1) {\r\n            (0, timer_1.setSeconds)(timerRep.value, newSeconds);\r\n        }\r\n    };\r\n    // If the timer was running when NodeCG was shut down last time,\r\n    // resume the timer according to how long it has been since the shutdown time.\r\n    if (timerRep.value && timerRep.value.timerState === 'Running') {\r\n        const missedSeconds = Math.round((Date.now() - timerRep.value.timestamp) / 1000);\r\n        (0, timer_1.setSeconds)(timerRep.value, timerRep.value.raw + missedSeconds);\r\n        start(true);\r\n    }\r\n    nodecg.listenFor('startTimer', start);\r\n    nodecg.listenFor('stopTimer', stop);\r\n    nodecg.listenFor('resetTimer', reset);\r\n    nodecg.listenFor('completeRunner', completeRunner);\r\n    nodecg.listenFor('resumeRunner', resumeRunner);\r\n    nodecg.listenFor('editTime', editTime);\r\n};\r\nexports.timekeeping = timekeeping;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.twitch = void 0;\r\nconst tslib_1 = require(\"tslib\");\r\nconst got_1 = (0, tslib_1.__importDefault)(require(\"got\"));\r\nconst app_root_path_1 = (0, tslib_1.__importDefault)(require(\"app-root-path\"));\r\nconst twitch = (nodecg) => {\r\n    const OUR_CHANNEL = nodecg.bundleConfig.twitchId;\r\n    // const CHANNEL_TITLE_PREFIX = nodecg.bundleConfig.broadcastTitlePrefix;\r\n    const log = new nodecg.Logger('twitch');\r\n    if (!nodecg.config.login ||\r\n        !nodecg.config.login.enabled ||\r\n        !nodecg.config.login.twitch ||\r\n        !nodecg.config.login.twitch.enabled) {\r\n        log.warn('Twitch login is disabled');\r\n        return;\r\n    }\r\n    const twitchConfig = nodecg.config.login.twitch;\r\n    if (!twitchConfig.scope.split(' ').includes('channel_editor')) {\r\n        log.error('Missing channel_editor scope, exiting.');\r\n        return;\r\n    }\r\n    const twitchRep = nodecg.Replicant('twitch', { defaultValue: {} });\r\n    const currentRunRep = nodecg.Replicant('current-run');\r\n    const { clientSecret } = app_root_path_1.default.require('./.nodecg/cfg/nodecg.json').login.twitch;\r\n    const refreshAccessToken = async () => {\r\n        try {\r\n            if (!twitchRep.value || !twitchRep.value.refresh) {\r\n                return;\r\n            }\r\n            const { body } = await got_1.default.post('https://id.twitch.tv/oauth2/token', {\r\n                form: true,\r\n                body: {\r\n                    grant_type: 'refresh_token',\r\n                    refresh_token: twitchRep.value.refresh.refreshToken,\r\n                    client_id: twitchConfig.clientID,\r\n                    client_secret: clientSecret,\r\n                    scope: twitchConfig.scope,\r\n                },\r\n            });\r\n            const response = JSON.parse(body);\r\n            const expiresInMs = response.expires_in * 1000;\r\n            setTimeout(refreshAccessToken, expiresInMs);\r\n            twitchRep.value.accessToken = response.access_token;\r\n            twitchRep.value.refresh = {\r\n                refreshToken: response.refresh_token,\r\n                refreshAt: Date.now() + expiresInMs,\r\n            };\r\n            log.info('Refreshed token');\r\n        }\r\n        catch (error) {\r\n            log.error('Failed to refresh token:', error);\r\n        }\r\n    };\r\n    let lastUpdateTitle = '';\r\n    const updateTitle = async (newRun) => {\r\n        try {\r\n            if (!newRun) {\r\n                return;\r\n            }\r\n            if (!twitchRep.value || !twitchRep.value.accessToken) {\r\n                log.error('Tried to update Twitch status but missing access token');\r\n                return;\r\n            }\r\n            // RTA Racing用\r\n            const genre = newRun.raceGenre ? `【${newRun.raceGenre}】` : '';\r\n            const newTitle = `${genre}${newRun.title} ${newRun.category} (${newRun.runners.map((runner) => runner.name).join('/')})`;\r\n            console.log(newTitle);\r\n            // RTA in 俺んち用\r\n            // const newTitle = `${CHANNEL_TITLE_PREFIX}${newRun.title}`;\r\n            if (lastUpdateTitle === newTitle) {\r\n                return;\r\n            }\r\n            await got_1.default.put(`https://api.twitch.tv/kraken/channels/${twitchRep.value.channelId}`, {\r\n                json: true,\r\n                body: {\r\n                    channel: {\r\n                        status: newTitle,\r\n                        game: newRun.englishTitle,\r\n                    },\r\n                },\r\n                headers: {\r\n                    Accept: 'application/vnd.twitchtv.v5+json',\r\n                    Authorization: `OAuth ${twitchRep.value.accessToken}`,\r\n                    'Client-ID': twitchConfig.clientID,\r\n                },\r\n            });\r\n            lastUpdateTitle = newTitle;\r\n            log.info(`Updated Twitch status to ${newRun.title} (${newRun.englishTitle})`);\r\n        }\r\n        catch (error) {\r\n            log.error('Failed to update Twitch status', error);\r\n        }\r\n    };\r\n    const loginLib = app_root_path_1.default.require('./.nodecg/lib/login');\r\n    loginLib.on('login', (session) => {\r\n        const { user } = session.passport;\r\n        if (user.provider !== 'twitch' || user.username !== OUR_CHANNEL) {\r\n            return;\r\n        }\r\n        twitchRep.value = {\r\n            accessToken: user.accessToken,\r\n            channelId: user.id,\r\n            refresh: {\r\n                refreshToken: user.refreshToken,\r\n                refreshAt: Date.now(),\r\n            },\r\n        };\r\n        log.info(`Twitch title updater is enabled for ${user.username}`);\r\n        refreshAccessToken();\r\n    });\r\n    currentRunRep.on('change', updateTitle);\r\n    twitchRep.once('change', (newVal) => {\r\n        if (newVal.refresh) {\r\n            const refreshIn = newVal.refresh.refreshAt - Date.now();\r\n            setTimeout(() => {\r\n                refreshAccessToken();\r\n            }, refreshIn);\r\n        }\r\n    });\r\n};\r\nexports.twitch = twitch;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.newTimer = exports.formatSeconds = exports.setSeconds = exports.decrement = exports.increment = exports.parseSeconds = exports.formatHMS = exports.secondsToHMS = void 0;\r\n/**\r\n * Parses a number of seconds into an HMS object.\r\n * @param seconds A number of seconds.\r\n * @returns An HMS object.\r\n */\r\nconst secondsToHMS = (seconds) => {\r\n    return {\r\n        h: Math.floor(seconds / 3600),\r\n        m: Math.floor((seconds % 3600) / 60),\r\n        s: Math.floor((seconds % 3600) % 60),\r\n    };\r\n};\r\nexports.secondsToHMS = secondsToHMS;\r\n/**\r\n * Formats an HMS object into a string ([hh:]mm:ss).\r\n * @param hms The HMS object to format.\r\n * @returns The formatted time string.\r\n */\r\nconst formatHMS = (hms) => {\r\n    let str = '';\r\n    if (hms.h) {\r\n        str += `${hms.h}:`;\r\n    }\r\n    str += `${hms.m < 10 ? `0${hms.m}` : hms.m}:${hms.s < 10 ? `0${hms.s}` : hms.s}`;\r\n    return str;\r\n};\r\nexports.formatHMS = formatHMS;\r\n/**\r\n * Parses a formatted time string into an integer of seconds.\r\n * @param timeString The formatted time string to parse (hh:mm:ss or mm:ss).\r\n * @returns The parsed time string represented as seconds.\r\n */\r\nconst parseSeconds = (timeString) => {\r\n    const timeParts = timeString.split(':').map(Number);\r\n    if (timeParts.length === 3) {\r\n        return (Math.floor((timeParts[0] || 0) * 3600) +\r\n            Math.floor((timeParts[1] || 0) * 60) +\r\n            Math.floor(timeParts[2] || 0));\r\n    }\r\n    if (timeParts.length === 2) {\r\n        return Math.floor((timeParts[0] || 0) * 60) + Math.floor(timeParts[1] || 0);\r\n    }\r\n    if (timeParts.length === 1) {\r\n        return Math.floor(timeParts[0] || 0);\r\n    }\r\n    throw new Error(`Unexpected format of timeString argument: ${timeString}`);\r\n};\r\nexports.parseSeconds = parseSeconds;\r\n/**\r\n * Increments a Timer by one second.\r\n * @param t - The Timer to increment.\r\n * @returns The Timer passed in as an argument.\r\n */\r\nconst increment = (t) => {\r\n    t.raw++;\r\n    const hms = (0, exports.secondsToHMS)(t.raw);\r\n    t.hours = hms.h;\r\n    t.minutes = hms.m;\r\n    t.seconds = hms.s;\r\n    t.formatted = (0, exports.formatHMS)(hms);\r\n    t.timestamp = Date.now();\r\n    return t;\r\n};\r\nexports.increment = increment;\r\n/**\r\n * Decrements a Timer by one second.\r\n * @param t The Timer to increment.\r\n * @returns The Timer passed in as an argument.\r\n */\r\nconst decrement = (t) => {\r\n    t.raw--;\r\n    const hms = (0, exports.secondsToHMS)(t.raw);\r\n    t.hours = hms.h;\r\n    t.minutes = hms.m;\r\n    t.seconds = hms.s;\r\n    t.formatted = (0, exports.formatHMS)(hms);\r\n    t.timestamp = Date.now();\r\n    return t;\r\n};\r\nexports.decrement = decrement;\r\n/**\r\n * Sets the value of a Timer.\r\n * @param t The Timer to set.\r\n * @param seconds The value to set to (in seconds).\r\n * @returns The Timer passed in as an argument.\r\n */\r\nconst setSeconds = (t, seconds) => {\r\n    const hms = (0, exports.secondsToHMS)(seconds);\r\n    t.hours = hms.h;\r\n    t.minutes = hms.m;\r\n    t.seconds = hms.s;\r\n    t.formatted = (0, exports.formatHMS)(hms);\r\n    t.raw = seconds;\r\n    t.timestamp = Date.now();\r\n    return t;\r\n};\r\nexports.setSeconds = setSeconds;\r\n/**\r\n * Formats a number of seconds into a string ([hh:]mm:ss).\r\n * @param seconds The number of seconds to format.\r\n * @returns The formatted time sting.\r\n */\r\nconst formatSeconds = (seconds) => {\r\n    const hms = (0, exports.secondsToHMS)(seconds);\r\n    return (0, exports.formatHMS)(hms);\r\n};\r\nexports.formatSeconds = formatSeconds;\r\n/**\r\n * Constructs a new Timer with the provided number of seconds.\r\n * @param seconds The value to instantiate this Timer with, in seconds.\r\n */\r\nconst newTimer = (seconds = 0) => {\r\n    const hms = (0, exports.secondsToHMS)(seconds);\r\n    return {\r\n        raw: seconds,\r\n        hours: hms.h,\r\n        minutes: hms.m,\r\n        seconds: hms.s,\r\n        formatted: (0, exports.formatHMS)(hms),\r\n        timestamp: Date.now(),\r\n        timerState: 'Stopped',\r\n        results: [null, null, null, null],\r\n        forfeit: false,\r\n    };\r\n};\r\nexports.newTimer = newTimer;\r\n","module.exports = require(\"app-root-path\");","module.exports = require(\"googleapis\");","module.exports = require(\"got\");","module.exports = require(\"lodash\");","module.exports = require(\"moment\");","module.exports = require(\"source-map-support/register\");","module.exports = require(\"tslib\");","module.exports = require(\"timers\");","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/extension/index.ts\");\n",""],"names":[],"sourceRoot":""}